import { getSoundStateFrame } from "./getSoundStateFrame";

const oneSecondInMs = 1000;
const oneMinuteInMs = oneSecondInMs * 60;

export const beginSoundLoop = ({
  callbacks,
  data,
  notes,
  update,
}) => {
  // Start by counting the first beat, which occurs outside the loop.

  const soundStateFrame = getSoundStateFrame(data);
  const {
    chord,
    key,
    octave,
    beats,
    bars,
  } = soundStateFrame;

  let {
    rands: {
      chordSize: chordSizeRand,
      key: keyRand,
      scale: scaleRand,
    },
  } = soundStateFrame;

  let updatedChord = [ ...chord ];
  let updatedOctave = octave;
  let updatedKey = key;

  const intervalId = setInterval(() => {
    // Change keys on the first beat of every 16 bars.
    if (bars && !beats && bars % 16 === 0) {
      if (bars % 32 === 0) {
        if (octave === 3) {
          updatedOctave += 1;
        } else if (octave === 4) {
          updatedOctave += Math.random() > 0.5 ? 1 : -1;
        } else if (octave === 5) {
          updatedOctave -= 1;
        }
      }

      // Autogenerated key from state.
      keyRand = Math.floor(Math.random() * 12);
      updatedKey = getKey(data, keyRand);
      updatedChord = getChord({
        root: updatedKey,
        octave,
        minorMajor,
        notes,
        data,
      });
    } else if (bars % 4 > 0 || beats > 0) {
      // Only require playing the key chord on the first beat of every 4 bars.
      scaleRand = Math.floor(Math.random() * 7);
      updatedChord = getChord({
        root: getNoteInScale(minorMajor, key, scaleRand),
        minorMajor,
        octave,
        notes,
        data,
      });
    }

    update({
      chord: updatedChord,
      key: updatedKey,
      octave: updatedOctave,
      rands: {
        chordSize: chordSizeRand,
        key: keyRand,
        scale: scaleRand,
      },
    });
  }, oneMinuteInMs / bpm);

  return intervalId;
};
